/**
 * date-time-adapter.class
 */
import { Subject } from 'rxjs';
import { inject, InjectionToken, LOCALE_ID } from '@angular/core';
/** InjectionToken for date time picker that can be used to override default locale code. */
export const OWL_DATE_TIME_LOCALE = new InjectionToken('OWL_DATE_TIME_LOCALE', {
    providedIn: 'root',
    factory: OWL_DATE_TIME_LOCALE_FACTORY
});
/** @docs-private */
export function OWL_DATE_TIME_LOCALE_FACTORY() {
    return inject(LOCALE_ID);
}
/** Provider for OWL_DATE_TIME_LOCALE injection token. */
export const OWL_DATE_TIME_LOCALE_PROVIDER = {
    provide: OWL_DATE_TIME_LOCALE,
    useExisting: LOCALE_ID
};
export class DateTimeAdapter {
    constructor() {
        /** A stream that emits when the locale changes. */
        this._localeChanges = new Subject();
        /** total milliseconds in a day. */
        this.millisecondsInDay = 86400000;
        /** total milliseconds in a minute. */
        this.milliseondsInMinute = 60000;
    }
    get localeChanges() {
        return this._localeChanges;
    }
    /**
     * Compare two given dates
     * 1 if the first date is after the second,
     * -1 if the first date is before the second
     * 0 if dates are equal.
     * */
    compare(first, second) {
        if (!this.isValid(first) || !this.isValid(second)) {
            throw Error('JSNativeDate: Cannot compare invalid dates.');
        }
        const dateFirst = this.clone(first);
        const dateSecond = this.clone(second);
        const diff = this.getTime(dateFirst) - this.getTime(dateSecond);
        if (diff < 0) {
            return -1;
        }
        else if (diff > 0) {
            return 1;
        }
        else {
            // Return 0 if diff is 0; return NaN if diff is NaN
            return diff;
        }
    }
    /**
     * Check if two given dates are in the same year
     * 1 if the first date's year is after the second,
     * -1 if the first date's year is before the second
     * 0 if two given dates are in the same year
     * */
    compareYear(first, second) {
        if (!this.isValid(first) || !this.isValid(second)) {
            throw Error('JSNativeDate: Cannot compare invalid dates.');
        }
        const yearLeft = this.getYear(first);
        const yearRight = this.getYear(second);
        const diff = yearLeft - yearRight;
        if (diff < 0) {
            return -1;
        }
        else if (diff > 0) {
            return 1;
        }
        else {
            return 0;
        }
    }
    /**
     * Attempts to deserialize a value to a valid date object. This is different from parsing in that
     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601
     * string). The default implementation does not allow any deserialization, it simply checks that
     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this
     * method on all of it's `@Input()` properties that accept dates. It is therefore possible to
     * support passing values from your backend directly to these properties by overriding this method
     * to also deserialize the format used by your backend.
     */
    deserialize(value) {
        if (value == null ||
            (this.isDateInstance(value) && this.isValid(value))) {
            return value;
        }
        return this.invalid();
    }
    /**
     * Sets the locale used for all dates.
     */
    setLocale(locale) {
        this.locale = locale;
        this._localeChanges.next();
    }
    /**
     * Clamp the given date between min and max dates.
     */
    clampDate(date, min, max) {
        if (min && this.compare(date, min) < 0) {
            return min;
        }
        if (max && this.compare(date, max) > 0) {
            return max;
        }
        return date;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLWFkYXB0ZXIuY2xhc3MuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZy1waWNrLWRhdGV0aW1lLyIsInNvdXJjZXMiOlsibGliL2RhdGUtdGltZS9hZGFwdGVyL2RhdGUtdGltZS1hZGFwdGVyLmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztHQUVHO0FBQ0gsT0FBTyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMzQyxPQUFPLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbEUsNEZBQTRGO0FBQzVGLE1BQU0sQ0FBQyxNQUFNLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUNsRCxzQkFBc0IsRUFDdEI7SUFDSSxVQUFVLEVBQUUsTUFBTTtJQUNsQixPQUFPLEVBQUUsNEJBQTRCO0NBQ3hDLENBQ0osQ0FBQztBQUVGLG9CQUFvQjtBQUNwQixNQUFNLFVBQVUsNEJBQTRCO0lBQ3hDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzdCLENBQUM7QUFFRCx5REFBeUQ7QUFDekQsTUFBTSxDQUFDLE1BQU0sNkJBQTZCLEdBQUc7SUFDekMsT0FBTyxFQUFFLG9CQUFvQjtJQUM3QixXQUFXLEVBQUUsU0FBUztDQUN6QixDQUFDO0FBRUYsTUFBTSxPQUFnQixlQUFlO0lBQXJDO1FBSUksbURBQW1EO1FBQ3pDLG1CQUFjLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUsvQyxtQ0FBbUM7UUFDaEIsc0JBQWlCLEdBQUcsUUFBUSxDQUFDO1FBRWhELHNDQUFzQztRQUNuQix3QkFBbUIsR0FBRyxLQUFLLENBQUM7SUFzUW5ELENBQUM7SUE5UUcsSUFBSSxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQy9CLENBQUM7SUFrTEQ7Ozs7O1NBS0s7SUFDTCxPQUFPLENBQUMsS0FBUSxFQUFFLE1BQVM7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQy9DLE1BQU0sS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7U0FDOUQ7UUFFRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFdEMsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRWhFLElBQUksSUFBSSxHQUFHLENBQUMsRUFBRTtZQUNWLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDYjthQUFNLElBQUksSUFBSSxHQUFHLENBQUMsRUFBRTtZQUNqQixPQUFPLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDSCxtREFBbUQ7WUFDbkQsT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNMLENBQUM7SUFFRDs7Ozs7U0FLSztJQUNMLFdBQVcsQ0FBQyxLQUFRLEVBQUUsTUFBUztRQUMzQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDL0MsTUFBTSxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztTQUM5RDtRQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV2QyxNQUFNLElBQUksR0FBRyxRQUFRLEdBQUcsU0FBUyxDQUFDO1FBRWxDLElBQUksSUFBSSxHQUFHLENBQUMsRUFBRTtZQUNWLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDYjthQUFNLElBQUksSUFBSSxHQUFHLENBQUMsRUFBRTtZQUNqQixPQUFPLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0gsV0FBVyxDQUFDLEtBQVU7UUFDbEIsSUFDSSxLQUFLLElBQUksSUFBSTtZQUNiLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQ3JEO1lBQ0UsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTLENBQUMsTUFBVztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVMsQ0FBQyxJQUFPLEVBQUUsR0FBYyxFQUFFLEdBQWM7UUFDN0MsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3BDLE9BQU8sR0FBRyxDQUFDO1NBQ2Q7UUFDRCxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDcEMsT0FBTyxHQUFHLENBQUM7U0FDZDtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBkYXRlLXRpbWUtYWRhcHRlci5jbGFzc1xyXG4gKi9cclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBpbmplY3QsIEluamVjdGlvblRva2VuLCBMT0NBTEVfSUQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbi8qKiBJbmplY3Rpb25Ub2tlbiBmb3IgZGF0ZSB0aW1lIHBpY2tlciB0aGF0IGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIGRlZmF1bHQgbG9jYWxlIGNvZGUuICovXHJcbmV4cG9ydCBjb25zdCBPV0xfREFURV9USU1FX0xPQ0FMRSA9IG5ldyBJbmplY3Rpb25Ub2tlbjxzdHJpbmc+KFxyXG4gICAgJ09XTF9EQVRFX1RJTUVfTE9DQUxFJyxcclxuICAgIHtcclxuICAgICAgICBwcm92aWRlZEluOiAncm9vdCcsXHJcbiAgICAgICAgZmFjdG9yeTogT1dMX0RBVEVfVElNRV9MT0NBTEVfRkFDVE9SWVxyXG4gICAgfVxyXG4pO1xyXG5cclxuLyoqIEBkb2NzLXByaXZhdGUgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIE9XTF9EQVRFX1RJTUVfTE9DQUxFX0ZBQ1RPUlkoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBpbmplY3QoTE9DQUxFX0lEKTtcclxufVxyXG5cclxuLyoqIFByb3ZpZGVyIGZvciBPV0xfREFURV9USU1FX0xPQ0FMRSBpbmplY3Rpb24gdG9rZW4uICovXHJcbmV4cG9ydCBjb25zdCBPV0xfREFURV9USU1FX0xPQ0FMRV9QUk9WSURFUiA9IHtcclxuICAgIHByb3ZpZGU6IE9XTF9EQVRFX1RJTUVfTE9DQUxFLFxyXG4gICAgdXNlRXhpc3Rpbmc6IExPQ0FMRV9JRFxyXG59O1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGVUaW1lQWRhcHRlcjxUPiB7XHJcbiAgICAvKiogVGhlIGxvY2FsZSB0byB1c2UgZm9yIGFsbCBkYXRlcy4gKi9cclxuICAgIHByb3RlY3RlZCBsb2NhbGU6IGFueTtcclxuXHJcbiAgICAvKiogQSBzdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy4gKi9cclxuICAgIHByb3RlY3RlZCBfbG9jYWxlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XHJcbiAgICBnZXQgbG9jYWxlQ2hhbmdlcygpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlQ2hhbmdlcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogdG90YWwgbWlsbGlzZWNvbmRzIGluIGEgZGF5LiAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IG1pbGxpc2Vjb25kc0luRGF5ID0gODY0MDAwMDA7XHJcblxyXG4gICAgLyoqIHRvdGFsIG1pbGxpc2Vjb25kcyBpbiBhIG1pbnV0ZS4gKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBtaWxsaXNlb25kc0luTWludXRlID0gNjAwMDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHllYXIgb2YgdGhlIGdpdmVuIGRhdGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0WWVhcihkYXRlOiBUKTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtb250aCBvZiB0aGUgZ2l2ZW4gZGF0ZVxyXG4gICAgICogMCAtLSBKYW51YXJ5XHJcbiAgICAgKiAxMSAtLSBEZWNlbWJlclxyXG4gICAgICogKi9cclxuICAgIGFic3RyYWN0IGdldE1vbnRoKGRhdGU6IFQpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRheSBvZiB0aGUgd2VlayBvZiB0aGUgZ2l2ZW4gZGF0ZVxyXG4gICAgICogMCAtLSBTdW5kYXlcclxuICAgICAqIDYgLS0gU2F0dXJkYXlcclxuICAgICAqICovXHJcbiAgICBhYnN0cmFjdCBnZXREYXkoZGF0ZTogVCk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZGF5IG51bSBvZiB0aGUgZ2l2ZW4gZGF0ZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXREYXRlKGRhdGU6IFQpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGhvdXJzIG9mIHRoZSBnaXZlbiBkYXRlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldEhvdXJzKGRhdGU6IFQpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG1pbnV0ZXMgb2YgdGhlIGdpdmVuIGRhdGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0TWludXRlcyhkYXRlOiBUKTogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzZWNvbmRzIG9mIHRoZSBnaXZlbiBkYXRlXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldFNlY29uZHMoZGF0ZTogVCk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWlsbGlzZWNvbmRzIHRpbWVzdGFtcCBvZiB0aGUgZ2l2ZW4gZGF0ZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRUaW1lKGRhdGU6IFQpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGggb2YgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGdldE51bURheXNJbk1vbnRoKGRhdGU6IFQpOiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjYWxlbmRhciBkYXlzIGJldHdlZW4gdGhlIGdpdmVuIGRhdGVzLlxyXG4gICAgICogSWYgZGF0ZUxlZnQgaXMgYmVmb3JlIGRhdGVSaWdodCwgaXQgd291bGQgcmV0dXJuIHBvc2l0aXZlIHZhbHVlXHJcbiAgICAgKiBJZiBkYXRlTGVmdCBpcyBhZnRlciBkYXRlUmlnaHQsIGl0IHdvdWxkIHJldHVybiBuZWdhdGl2ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF0ZUxlZnQ6IFQsIGRhdGVSaWdodDogVCk6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG5hbWUgZm9yIHRoZSB5ZWFyIG9mIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRZZWFyTmFtZShkYXRlOiBUKTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgbGlzdCBvZiBtb250aCBuYW1lc1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXRNb250aE5hbWVzKHN0eWxlOiAnbG9uZycgfCAnc2hvcnQnIHwgJ25hcnJvdycpOiBzdHJpbmdbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGxpc3Qgb2Ygd2VlayBuYW1lc1xyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBnZXREYXlPZldlZWtOYW1lcyhzdHlsZTogJ2xvbmcnIHwgJ3Nob3J0JyB8ICduYXJyb3cnKTogc3RyaW5nW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBuYW1lcyBmb3IgdGhlIGRhdGVzIG9mIHRoZSBtb250aC5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgZ2V0RGF0ZU5hbWVzKCk6IHN0cmluZ1tdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgRGF0ZSBvYmplY3QgYXMgYSBzdHJpbmcsIHVzaW5nIHRoZSBJU08gc3RhbmRhcmRcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgdG9Jc284NjAxKGRhdGU6IFQpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZSBkYXRlcyBhcmUgZXF1YWxcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgaXNFcXVhbChkYXRlTGVmdDogVCwgZGF0ZVJpZ2h0OiBUKTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlIGRhdGVzIGFyZSB0aGUgc2FtZSBkYXlcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgaXNTYW1lRGF5KGRhdGVMZWZ0OiBULCBkYXRlUmlnaHQ6IFQpOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGRhdGUgaXMgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGlzVmFsaWQoZGF0ZTogVCk6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGRhdGUgaW5zdGFuY2UgdGhhdCBpcyBub3QgdmFsaWQuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGludmFsaWQoKTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgY29uc2lkZXJlZCBhIGRhdGUgaW5zdGFuY2UgYnkgdGhpcyBEYXRlVGltZUFkYXB0ZXIuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IGlzRGF0ZUluc3RhbmNlKG9iajogYW55KTogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB5ZWFycyB0byB0aGUgZ2l2ZW4gZGF0ZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBhZGRDYWxlbmRhclllYXJzKGRhdGU6IFQsIGFtb3VudDogbnVtYmVyKTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBtb250aHMgdG8gdGhlIGdpdmVuIGRhdGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgYWRkQ2FsZW5kYXJNb250aHMoZGF0ZTogVCwgYW1vdW50OiBudW1iZXIpOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGRheXMgdG8gdGhlIGdpdmVuIGRhdGVcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgYWRkQ2FsZW5kYXJEYXlzKGRhdGU6IFQsIGFtb3VudDogbnVtYmVyKTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgaG91cnMgdG8gdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldEhvdXJzKGRhdGU6IFQsIGFtb3VudDogbnVtYmVyKTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWludXRlcyB0byB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3Qgc2V0TWludXRlcyhkYXRlOiBULCBhbW91bnQ6IG51bWJlcik6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNlY29uZHMgdG8gdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAgKi9cclxuICAgIGFic3RyYWN0IHNldFNlY29uZHMoZGF0ZTogVCwgYW1vdW50OiBudW1iZXIpOiBUO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGRhdGUgd2l0aCB0aGUgZ2l2ZW4geWVhciwgbW9udGgsIGRhdGUsIGhvdXIsIG1pbnV0ZSBhbmQgc2Vjb25kLiBEb2VzIG5vdCBhbGxvdyBvdmVyL3VuZGVyLWZsb3cgb2YgdGhlXHJcbiAgICAgKiBtb250aCBhbmQgZGF0ZS5cclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgY3JlYXRlRGF0ZSh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRhdGU6IG51bWJlcik6IFQ7XHJcbiAgICBhYnN0cmFjdCBjcmVhdGVEYXRlKFxyXG4gICAgICAgIHllYXI6IG51bWJlcixcclxuICAgICAgICBtb250aDogbnVtYmVyLFxyXG4gICAgICAgIGRhdGU6IG51bWJlcixcclxuICAgICAgICBob3VyczogbnVtYmVyLFxyXG4gICAgICAgIG1pbnV0ZXM6IG51bWJlcixcclxuICAgICAgICBzZWNvbmRzOiBudW1iZXJcclxuICAgICk6IFQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZSB0aGUgZ2l2ZW4gZGF0ZVxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBjbG9uZShkYXRlOiBUKTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIG5ldyBtb21lbnRcclxuICAgICAqICovXHJcbiAgICBhYnN0cmFjdCBub3coKTogVDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdHMgYSBkYXRlIGFzIGEgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBhYnN0cmFjdCBmb3JtYXQoZGF0ZTogVCwgZGlzcGxheUZvcm1hdDogYW55KTogc3RyaW5nO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYSB1c2VyLXByb3ZpZGVkIHZhbHVlIHRvIGEgRGF0ZSBPYmplY3RcclxuICAgICAqL1xyXG4gICAgYWJzdHJhY3QgcGFyc2UodmFsdWU6IGFueSwgcGFyc2VGb3JtYXQ6IGFueSk6IFQgfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGFyZSB0d28gZ2l2ZW4gZGF0ZXNcclxuICAgICAqIDEgaWYgdGhlIGZpcnN0IGRhdGUgaXMgYWZ0ZXIgdGhlIHNlY29uZCxcclxuICAgICAqIC0xIGlmIHRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kXHJcbiAgICAgKiAwIGlmIGRhdGVzIGFyZSBlcXVhbC5cclxuICAgICAqICovXHJcbiAgICBjb21wYXJlKGZpcnN0OiBULCBzZWNvbmQ6IFQpOiBudW1iZXIge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGZpcnN0KSB8fCAhdGhpcy5pc1ZhbGlkKHNlY29uZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0pTTmF0aXZlRGF0ZTogQ2Fubm90IGNvbXBhcmUgaW52YWxpZCBkYXRlcy4nKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGVGaXJzdCA9IHRoaXMuY2xvbmUoZmlyc3QpO1xyXG4gICAgICAgIGNvbnN0IGRhdGVTZWNvbmQgPSB0aGlzLmNsb25lKHNlY29uZCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLmdldFRpbWUoZGF0ZUZpcnN0KSAtIHRoaXMuZ2V0VGltZShkYXRlU2Vjb25kKTtcclxuXHJcbiAgICAgICAgaWYgKGRpZmYgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJldHVybiAwIGlmIGRpZmYgaXMgMDsgcmV0dXJuIE5hTiBpZiBkaWZmIGlzIE5hTlxyXG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0d28gZ2l2ZW4gZGF0ZXMgYXJlIGluIHRoZSBzYW1lIHllYXJcclxuICAgICAqIDEgaWYgdGhlIGZpcnN0IGRhdGUncyB5ZWFyIGlzIGFmdGVyIHRoZSBzZWNvbmQsXHJcbiAgICAgKiAtMSBpZiB0aGUgZmlyc3QgZGF0ZSdzIHllYXIgaXMgYmVmb3JlIHRoZSBzZWNvbmRcclxuICAgICAqIDAgaWYgdHdvIGdpdmVuIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSB5ZWFyXHJcbiAgICAgKiAqL1xyXG4gICAgY29tcGFyZVllYXIoZmlyc3Q6IFQsIHNlY29uZDogVCk6IG51bWJlciB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoZmlyc3QpIHx8ICF0aGlzLmlzVmFsaWQoc2Vjb25kKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSlNOYXRpdmVEYXRlOiBDYW5ub3QgY29tcGFyZSBpbnZhbGlkIGRhdGVzLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeWVhckxlZnQgPSB0aGlzLmdldFllYXIoZmlyc3QpO1xyXG4gICAgICAgIGNvbnN0IHllYXJSaWdodCA9IHRoaXMuZ2V0WWVhcihzZWNvbmQpO1xyXG5cclxuICAgICAgICBjb25zdCBkaWZmID0geWVhckxlZnQgLSB5ZWFyUmlnaHQ7XHJcblxyXG4gICAgICAgIGlmIChkaWZmIDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRlbXB0cyB0byBkZXNlcmlhbGl6ZSBhIHZhbHVlIHRvIGEgdmFsaWQgZGF0ZSBvYmplY3QuIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gcGFyc2luZyBpbiB0aGF0XHJcbiAgICAgKiBkZXNlcmlhbGl6ZSBzaG91bGQgb25seSBhY2NlcHQgbm9uLWFtYmlndW91cywgbG9jYWxlLWluZGVwZW5kZW50IGZvcm1hdHMgKGUuZy4gYSBJU08gODYwMVxyXG4gICAgICogc3RyaW5nKS4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZG9lcyBub3QgYWxsb3cgYW55IGRlc2VyaWFsaXphdGlvbiwgaXQgc2ltcGx5IGNoZWNrcyB0aGF0XHJcbiAgICAgKiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYWxyZWFkeSBhIHZhbGlkIGRhdGUgb2JqZWN0IG9yIG51bGwuIFRoZSBgPG1hdC1kYXRlcGlja2VyPmAgd2lsbCBjYWxsIHRoaXNcclxuICAgICAqIG1ldGhvZCBvbiBhbGwgb2YgaXQncyBgQElucHV0KClgIHByb3BlcnRpZXMgdGhhdCBhY2NlcHQgZGF0ZXMuIEl0IGlzIHRoZXJlZm9yZSBwb3NzaWJsZSB0b1xyXG4gICAgICogc3VwcG9ydCBwYXNzaW5nIHZhbHVlcyBmcm9tIHlvdXIgYmFja2VuZCBkaXJlY3RseSB0byB0aGVzZSBwcm9wZXJ0aWVzIGJ5IG92ZXJyaWRpbmcgdGhpcyBtZXRob2RcclxuICAgICAqIHRvIGFsc28gZGVzZXJpYWxpemUgdGhlIGZvcm1hdCB1c2VkIGJ5IHlvdXIgYmFja2VuZC5cclxuICAgICAqL1xyXG4gICAgZGVzZXJpYWxpemUodmFsdWU6IGFueSk6IFQgfCBudWxsIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHZhbHVlID09IG51bGwgfHxcclxuICAgICAgICAgICAgKHRoaXMuaXNEYXRlSW5zdGFuY2UodmFsdWUpICYmIHRoaXMuaXNWYWxpZCh2YWx1ZSkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbG9jYWxlIHVzZWQgZm9yIGFsbCBkYXRlcy5cclxuICAgICAqL1xyXG4gICAgc2V0TG9jYWxlKGxvY2FsZTogYW55KSB7XHJcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxlQ2hhbmdlcy5uZXh0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFtcCB0aGUgZ2l2ZW4gZGF0ZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IGRhdGVzLlxyXG4gICAgICovXHJcbiAgICBjbGFtcERhdGUoZGF0ZTogVCwgbWluPzogVCB8IG51bGwsIG1heD86IFQgfCBudWxsKTogVCB7XHJcbiAgICAgICAgaWYgKG1pbiAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgbWluKSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heCAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgbWF4KSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1heDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9XHJcbn1cclxuIl19